#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>

#include "windows.h"

using namespace std;

const string kExecutableName = "supercalifragilistic.exe";

// Tests if a string has a certain ending
inline bool ends_with(const string &str, const string &ending)
{
    if (ending.size() > str.size()) {
        return false;
    }
    return equal(ending.rbegin(), ending.rend(), str.rbegin());
}

// Runs a process and waits for it to stop before continuing
void RunAndWait(const string &process, const string &parameters)
{
    SHELLEXECUTEINFO sh_exec_info = {0};
    sh_exec_info.cbSize = sizeof(SHELLEXECUTEINFO);
    sh_exec_info.fMask = SEE_MASK_NOCLOSEPROCESS;
    sh_exec_info.hwnd = NULL;
    sh_exec_info.lpVerb = NULL;
    sh_exec_info.lpFile = process.c_str();
    sh_exec_info.lpParameters = parameters.c_str();
    sh_exec_info.lpDirectory = "";
    sh_exec_info.nShow = SW_HIDE;
    sh_exec_info.hInstApp = NULL;

    ShellExecuteEx(&sh_exec_info);
    WaitForSingleObject(sh_exec_info.hProcess, INFINITE);
}

// Compiles the source whose name is given as a parameter
// Decides automatically which compile instruction to use based on file extension
void CompileSource(const string &source_name)
{
    string compile_process = "";
    string compile_parameters = "";

    if (ends_with(source_name, ".c")) {
        compile_process = "gcc";
        compile_parameters = "-Wall -Werror " + source_name + " -o " + kExecutableName;
    } else if (ends_with(source_name, ".cpp") || ends_with(source_name, ".cc")) {
        compile_process = "g++";
        compile_parameters = "-Wall -Werror -std=c++11 " + source_name + " -o " + kExecutableName;
    } else {
        throw invalid_argument(source_name + " does not have a supported file extension");
    }

    // Do the actual compiling
    RunAndWait(compile_process, compile_parameters);
}

int to_int(const string &str)
{
    int num = 0;
    int sign = 1;

    unsigned start_pos = 0;
    if (str[0] == '-') {
        sign = -1;
        ++start_pos;
    }

    for (unsigned i = start_pos; i < str.size(); ++i) {
        if (str[i] >= '0' && str[i] <= '9') {
            num = num * 10 + str[i] - '0';
        } else {
            throw invalid_argument(str + " is not a number");
        }
    }
    return sign * num;
}

// Returns the name of the file containing input for a certain test
inline string input_filename(const string &prefix, int test_number)
{
    stringstream ss;
    ss << prefix << "." << test_number << ".in";
    return ss.str();
}

// Returns the name of the input file used by the user program
inline string input_filename(const string &prefix)
{
    return prefix + ".in";
}

// Returns the name of the file containing the correct output for a certain test
inline string output_filename(const string &prefix, int test_number)
{
    stringstream ss;
    ss << prefix << "." << test_number << ".out";
    return ss.str();
}

// Returns the name of the output file generated by the user program
inline string output_filename(const string &prefix)
{
    return prefix + ".out";
}

// Checks if a certain test was solved correcly
bool IsTestCorrect(const string &prefix, int test_number)
{
    ifstream user_fin(output_filename(prefix));
    ifstream correct_fin(output_filename(prefix, test_number));

    if (!user_fin.is_open()) {
        throw runtime_error("Could not open user output file");
    }
    if (!correct_fin.is_open()) {
        throw runtime_error("Could not open correct output file");
    }

    // Compare each line
    int line_number = 0;
    while (!user_fin.eof() && !correct_fin.eof()) {
        string user_line;
        getline(user_fin, user_line);

        string correct_line;
        getline(correct_fin, correct_line);

        ++line_number;
        if (user_line != correct_line) {
            cout << "line #" << line_number << "\n";
            cout << "user line:\t" << user_line << "\n";
            cout << "correct line:\t" << correct_line << "\n";
            return false;
        }
    }

    if (user_fin.eof() && !correct_fin.eof()) {
        cout << "user output ended too early\n";
        return false;
    }

    if (!user_fin.eof() && correct_fin.eof()) {
        cout << "user ouput ended too late\n";
        return false;
    }
    return true;
}

// Copies the input of a certain test into the user input file
void CopyTest(const string &prefix, int test_number)
{
    ifstream fin(input_filename(prefix, test_number));
    ofstream fout(input_filename(prefix));

    if (!fin.is_open()) {
        throw runtime_error("Could not open test input file");
    }
    if (!fout.is_open()) {
        throw runtime_error("Could not open user input file");
    }

    string line;
    while (getline(fin, line)) {
        fout << line << "\n";
    }
}

int main(int argc, char* argv[])
{
    if (argc != 5) {
        cout << "The program expects these arguments:\n"
                " - [path from this directory to destination]\n"
                " - [source name]\n"
                " - [test-files name]\n"
                " - [number of tests]\n";
        return 0;
    }

    // Navigate to target directory
    SetCurrentDirectory(argv[1]);

    // Try to compile the source
    try {
        // argv[2] contains the source name
        CompileSource(argv[2]);
    } catch (const invalid_argument &ia) {
        cerr << ia.what() << "\n";
        return 0;
    }

    string test_file_prefix = argv[3];
    int tests;

    // Parse numeric input
    try {
        tests = to_int(argv[4]);
    } catch (const  invalid_argument &ia) {
        cerr << ia.what() << "\n";
        return 0;
    }

    try {
        for (int i = 1; i <= tests; ++i) {
            // Copy the current test data into the input file
            CopyTest(test_file_prefix, i);

            // Start the program
            RunAndWait(kExecutableName, "");

            // Show test result
            cout << "Test #" << i << ": " << 
                (IsTestCorrect(test_file_prefix, i) ? "CORRECT" : "wrong") << "\n\n";
        }
    } catch(const exception &e) {
        cerr << "An error occured during testing\n";
        cerr << e.what() << "\n";
        return 1;
    }

    return 0;
}
